{"version":3,"sources":["../src/builder.ts"],"names":["RefsTracker","text","value","schema","stripped","textIndex","refs","isEven","n","match","refToken","skipChars","refName","index","skipLen","length","slice","node","offsetRefs","offset","result","name","hasOwnProperty","sequence","content","position","nodes","isRefsTracker","isRefsNode","thickness","isText","nodeSize","push","coerce","refsContent","map","item","nodeFactory","type","attrs","marks","nodeBuilder","Error","Object","keys","join","createChecked","markFactory","allowDupes","markBuilder","mark","create","isInSet","refNode","addToSet","fragment","Slice","Fragment","from","testSchema","clean","Array","isArray","reduce","acc","next","Node","fromJSON","toJSON","undefined"],"mappings":";;;;;;;;;;;;;;;AAAA;;AAEA;;AACA;;;;;;;;AAqCA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBO,MAAMA,WAAN,CAAkB;AAIzB;;;;;;;AAOA;;;;;;;AAOO,SAASC,IAAT,CAAcC,KAAd,EAA6BC,MAA7B,EAA8D;AACnE,MAAIC,QAAQ,GAAG,EAAf;AACA,MAAIC,SAAS,GAAG,CAAhB;AACA,QAAMC,IAAU,GAAG,EAAnB,CAHmE,CAKnE;;AACA,QAAMC,MAAM,GAAIC,CAAD,IAAeA,CAAC,GAAG,CAAJ,KAAU,CAAxC;;AAEA,OAAK,MAAMC,KAAX,IAAoB,uBAAYP,KAAZ,EAAmB,qCAAnB,CAApB,EAA+E;AAC7E,UAAM,CAACQ,QAAD,EAAWC,SAAX,EAAsBC,OAAtB,IAAiCH,KAAvC;AACA,QAAI;AAAEI,MAAAA;AAAF,QAAYJ,KAAhB;AAEA,UAAMK,OAAO,GAAGH,SAAS,IAAIA,SAAS,CAACI,MAAvC;;AACA,QAAID,OAAJ,EAAa;AACX,UAAIP,MAAM,CAACO,OAAD,CAAV,EAAqB;AACnBD,QAAAA,KAAK,IAAIC,OAAO,GAAG,CAAnB;AACD,OAFD,MAEO;AACLV,QAAAA,QAAQ,IAAIF,KAAK,CAACc,KAAN,CAAYX,SAAZ,EAAuBQ,KAAK,GAAG,CAACC,OAAO,GAAG,CAAX,IAAgB,CAA/C,CAAZ;AACAV,QAAAA,QAAQ,IAAIF,KAAK,CAACc,KAAN,CAAYH,KAAK,GAAGC,OAApB,EAA6BD,KAAK,GAAGH,QAAQ,CAACK,MAA9C,CAAZ;AACAV,QAAAA,SAAS,GAAGQ,KAAK,GAAGH,QAAQ,CAACK,MAA7B;AACA;AACD;AACF;;AAEDX,IAAAA,QAAQ,IAAIF,KAAK,CAACc,KAAN,CAAYX,SAAZ,EAAuBQ,KAAvB,CAAZ;AACAP,IAAAA,IAAI,CAACM,OAAD,CAAJ,GAAgBR,QAAQ,CAACW,MAAzB;AACAV,IAAAA,SAAS,GAAGI,KAAK,CAACI,KAAN,GAAcH,QAAQ,CAACK,MAAnC;AACD;;AAEDX,EAAAA,QAAQ,IAAIF,KAAK,CAACc,KAAN,CAAYX,SAAZ,CAAZ;AAEA,QAAMY,IAAI,GAAGb,QAAQ,KAAK,EAAb,GAAkB,IAAIJ,WAAJ,EAAlB,GAAuCG,MAAM,CAACF,IAAP,CAAYG,QAAZ,CAApD;AAEAa,EAAAA,IAAI,CAACX,IAAL,GAAYA,IAAZ;AACA,SAAOW,IAAP;AACD;AAED;;;;;AAGO,SAASC,UAAT,CAAoBZ,IAApB,EAAgCa,MAAhC,EAAsD;AAC3D,QAAMC,MAAM,GAAG,EAAf;;AACA,OAAK,MAAMC,IAAX,IAAmBf,IAAnB,EAAyB;AACvB,QAAIA,IAAI,CAACgB,cAAL,CAAoBD,IAApB,CAAJ,EAA+B;AAC7BD,MAAAA,MAAM,CAACC,IAAD,CAAN,GAAef,IAAI,CAACe,IAAD,CAAJ,GAAaF,MAA5B;AACD;AACF;;AACD,SAAOC,MAAP;AACD;AAED;;;;;;AAIO,SAASG,QAAT,CAAkB,GAAGC,OAArB,EAAiD;AACtD,MAAIC,QAAQ,GAAG,CAAf;AACA,MAAInB,IAAI,GAAG,EAAX;AACA,QAAMoB,KAAK,GAAG,EAAd,CAHsD,CAKtD;AACA;;AACA,QAAMC,aAAa,GAAInB,CAAD,IAA8BA,CAAC,YAAYR,WAAjE;;AACA,QAAM4B,UAAU,GAAIpB,CAAD,IAA2B,CAACmB,aAAa,CAACnB,CAAD,CAA5D;;AAEA,OAAK,MAAMS,IAAX,IAAmBO,OAAnB,EAA4B;AAC1B,QAAIG,aAAa,CAACV,IAAD,CAAjB,EAAyB;AACvBX,MAAAA,IAAI,qBAAQA,IAAR,EAAiBY,UAAU,CAACD,IAAI,CAACX,IAAN,EAAYmB,QAAZ,CAA3B,CAAJ;AACD;;AACD,QAAIG,UAAU,CAACX,IAAD,CAAd,EAAsB;AACpB,YAAMY,SAAS,GAAGZ,IAAI,CAACa,MAAL,GAAc,CAAd,GAAkB,CAApC;AACAxB,MAAAA,IAAI,qBAAQA,IAAR,EAAiBY,UAAU,CAACD,IAAI,CAACX,IAAN,EAAYmB,QAAQ,GAAGI,SAAvB,CAA3B,CAAJ;AACAJ,MAAAA,QAAQ,IAAIR,IAAI,CAACc,QAAjB;AACAL,MAAAA,KAAK,CAACM,IAAN,CAAWf,IAAX;AACD;AACF;;AACD,SAAO;AAAES,IAAAA,KAAF;AAASpB,IAAAA;AAAT,GAAP;AACD;AAED;;;;;AAGO,SAAS2B,MAAT,CAAgBT,OAAhB,EAA2CrB,MAA3C,EAA2D;AAChE,QAAM+B,WAAW,GAAGV,OAAO,CAACW,GAAR,CAAYC,IAAI,IAClC,OAAOA,IAAP,KAAgB,QAAhB,GAA2BnC,IAAI,CAACmC,IAAD,EAAOjC,MAAP,CAA/B,GAAgDiC,IAAI,CAACjC,MAAD,CADlC,CAApB;AAGA,SAAOoB,QAAQ,CAAC,GAAG,uBAAyBW,WAAzB,CAAJ,CAAf;AACD;AAED;;;;;AAGO,SAASG,WAAT,CAAqBC,IAArB,EAAqCC,KAAK,GAAG,EAA7C,EAAiDC,KAAjD,EAAiE;AACtE,SAAO,CAAC,GAAGhB,OAAJ,KAAkE;AACvE,WAAOrB,MAAM,IAAI;AACf,YAAM;AAAEuB,QAAAA,KAAF;AAASpB,QAAAA;AAAT,UAAkB2B,MAAM,CAACT,OAAD,EAAUrB,MAAV,CAA9B;AACA,YAAMsC,WAAW,GAAGtC,MAAM,CAACuB,KAAP,CAAaY,IAAI,CAACjB,IAAlB,CAApB;;AACA,UAAI,CAACoB,WAAL,EAAkB;AAChB,cAAM,IAAIC,KAAJ,CACH,UACCJ,IAAI,CAACjB,IACN,sIAAqIsB,MAAM,CAACC,IAAP,CACpIzC,MAAM,CAACuB,KAD6H,EAEpImB,IAFoI,CAE/H,IAF+H,CAEzH,EALT,CAAN;AAOD;;AACD,YAAM5B,IAAI,GAAGwB,WAAW,CAACK,aAAZ,CAA0BP,KAA1B,EAAiCb,KAAjC,EAAwCc,KAAxC,CAAb;AACAvB,MAAAA,IAAI,CAACX,IAAL,GAAYA,IAAZ;AACA,aAAOW,IAAP;AACD,KAfD;AAgBD,GAjBD;AAkBD;AAED;;;;;AAGO,SAAS8B,WAAT,CAAqBT,IAArB,EAAqCC,KAAK,GAAG,EAA7C,EAAiDS,UAAU,GAAG,KAA9D,EAAqE;AAC1E,SAAO,CAAC,GAAGxB,OAAJ,KAAoE;AACzE,WAAOrB,MAAM,IAAI;AACf,YAAM8C,WAAW,GAAG9C,MAAM,CAACqC,KAAP,CAAaF,IAAI,CAACjB,IAAlB,CAApB;;AACA,UAAI,CAAC4B,WAAL,EAAkB;AAChB,cAAM,IAAIP,KAAJ,CACH,UACCJ,IAAI,CAACjB,IACN,sIAAqIsB,MAAM,CAACC,IAAP,CACpIzC,MAAM,CAACqC,KAD6H,EAEpIK,IAFoI,CAE/H,IAF+H,CAEzH,EALT,CAAN;AAOD;;AACD,YAAMK,IAAI,GAAGD,WAAW,CAACE,MAAZ,CAAmBZ,KAAnB,CAAb;AACA,YAAM;AAAEb,QAAAA;AAAF,UAAYO,MAAM,CAACT,OAAD,EAAUrB,MAAV,CAAxB;AACA,aAAOuB,KAAK,CAACS,GAAN,CAAUlB,IAAI,IAAI;AACvB,YAAI,CAAC+B,UAAD,IAAeE,IAAI,CAACZ,IAAL,CAAUc,OAAV,CAAkBnC,IAAI,CAACuB,KAAvB,CAAnB,EAAkD;AAChD,iBAAOvB,IAAP;AACD,SAFD,MAEO;AACL,gBAAMoC,OAAO,GAAGpC,IAAI,CAACiC,IAAL,CAAUA,IAAI,CAACI,QAAL,CAAcrC,IAAI,CAACuB,KAAnB,CAAV,CAAhB;AACAa,UAAAA,OAAO,CAAC/C,IAAR,GAAeW,IAAI,CAACX,IAApB;AACA,iBAAO+C,OAAP;AACD;AACF,OARM,CAAP;AASD,KAtBD;AAuBD,GAxBD;AAyBD;;AAEM,MAAME,QAAQ,GAAG,CAAC,GAAG/B,OAAJ,KAAkC,uBAAwBA,OAAxB,CAAnD;;;;AACA,MAAMR,KAAK,GAAG,CAAC,GAAGQ,OAAJ,KACnB,IAAIgC,uBAAJ,CAAUC,2BAASC,IAAT,CAAczB,MAAM,CAACT,OAAD,EAAUmC,sBAAV,CAAN,CAA4BjC,KAA1C,CAAV,EAA4D,CAA5D,EAA+D,CAA/D,CADK;AAGP;;;;;;;AAGO,MAAMkC,KAAK,GAAIpC,OAAD,IAAgCrB,MAAD,IAAoB;AACtE,QAAMc,IAAI,GAAGO,OAAO,CAACrB,MAAD,CAApB;;AACA,MAAI0D,KAAK,CAACC,OAAN,CAAc7C,IAAd,CAAJ,EAAyB;AACvB,WAAOA,IAAI,CAAC8C,MAAL,CACL,CAACC,GAAD,EAAMC,IAAN,KAAe;AACb,UAAIA,IAAI,YAAYC,sBAApB,EAA0B;AACxBF,QAAAA,GAAG,CAAChC,IAAJ,CAASkC,uBAAKC,QAAL,CAAchE,MAAd,EAAsB8D,IAAI,CAACG,MAAL,EAAtB,CAAT;AACD;;AACD,aAAOJ,GAAP;AACD,KANI,EAOL,EAPK,CAAP;AASD;;AACD,SAAO/C,IAAI,YAAYiD,sBAAhB,GAAuBA,uBAAKC,QAAL,CAAchE,MAAd,EAAsBc,IAAI,CAACmD,MAAL,EAAtB,CAAvB,GAA8DC,SAArE;AACD,CAdM","sourcesContent":["import { findMatches } from '@remirror/core';\nimport { flatten } from 'lodash';\nimport { Fragment, Mark, MarkType, Node, NodeType, Schema, Slice } from 'prosemirror-model';\nimport { testSchema } from './test-schema';\n\n/**\n * Represents a ProseMirror \"position\" in a document.\n */\nexport type RefPosition = number;\n\n/**\n * A useful feature of the builder is being able to declaratively mark positions\n * in content using the curly braces e.g. `{<>}`.\n *\n * These positions are called \"refs\" (inspired by React), and are tracked on\n * every node in the tree that has a ref on any of its descendants.\n */\nexport interface Refs {\n  [name: string]: RefPosition;\n}\n\n/**\n * Content that contains refs information.\n */\nexport type RefsContentItem = RefsNode | RefsTracker;\n\n/**\n * Content node or mark builders can consume, e.g.\n *\n *     const builder = nodeFactory('p');\n *     builder('string');\n *     builder(aNode);\n *     builder(aRefsNode);\n *     builder(aRefsTracker);\n *     builder([aNode, aRefsNode, aRefsTracker]);\n */\n\nexport type BuilderContentFn = (schema: Schema) => Node | RefsContentItem | Array<Node | RefsContentItem>;\nexport type BuilderContent = string | BuilderContentFn;\n\n/**\n * ProseMirror doesn't support empty text nodes, which can be quite\n * inconvenient when you want to capture a position ref without introducing\n * text.\n *\n * Take a couple of examples:\n *\n *     p('{<>}')\n *     p('Hello ', '{<>}', 'world!')\n *\n * After the ref syntax is stripped you're left with:\n *\n *     p('')\n *     p('Hello ', '', 'world!')\n *\n * This violates the rule of text nodes being non-empty. This class solves the\n * problem by providing an alternative data structure that *only* stores refs,\n * and can be used in scenarios where an empty text would be forbidden.\n *\n * This is done under the hood when using `text()` factory, and instead of\n * always returning a text node, it'll instead return one of two things:\n *\n * - a text node -- when given a non-empty string\n * - a refs tracker -- when given a string that *only* contains refs.\n */\nexport class RefsTracker {\n  public refs!: Refs;\n}\n\n/**\n * A standard ProseMirror Node that also tracks refs.\n */\nexport interface RefsNode extends Node {\n  refs: Refs;\n}\n\n/**\n * Create a text node.\n *\n * Special markers called \"refs\" can be put in the text. Refs provide a way to\n * declaratively describe a position within some text, and then access the\n * position in the resulting node.\n */\nexport function text(value: string, schema: Schema): RefsContentItem {\n  let stripped = '';\n  let textIndex = 0;\n  const refs: Refs = {};\n\n  // Helpers\n  const isEven = (n: number) => n % 2 === 0;\n\n  for (const match of findMatches(value, /([\\\\]+)?{(\\w+|<|>|<>|<cell|cell>)}/g)) {\n    const [refToken, skipChars, refName] = match;\n    let { index } = match;\n\n    const skipLen = skipChars && skipChars.length;\n    if (skipLen) {\n      if (isEven(skipLen)) {\n        index += skipLen / 2;\n      } else {\n        stripped += value.slice(textIndex, index + (skipLen - 1) / 2);\n        stripped += value.slice(index + skipLen, index + refToken.length);\n        textIndex = index + refToken.length;\n        continue;\n      }\n    }\n\n    stripped += value.slice(textIndex, index);\n    refs[refName] = stripped.length;\n    textIndex = match.index + refToken.length;\n  }\n\n  stripped += value.slice(textIndex);\n\n  const node = stripped === '' ? new RefsTracker() : (schema.text(stripped) as RefsNode);\n\n  node.refs = refs;\n  return node;\n}\n\n/**\n * Offset ref position values by some amount.\n */\nexport function offsetRefs(refs: Refs, offset: number): Refs {\n  const result = {} as Refs;\n  for (const name in refs) {\n    if (refs.hasOwnProperty(name)) {\n      result[name] = refs[name] + offset;\n    }\n  }\n  return result;\n}\n\n/**\n * Given a collection of nodes, sequence them in an array and return the result\n * along with the updated refs.\n */\nexport function sequence(...content: RefsContentItem[]) {\n  let position = 0;\n  let refs = {} as Refs;\n  const nodes = [] as RefsNode[];\n\n  // It's bizarre that this is necessary. An if/else in the for...of should have\n  // sufficient but it did not work at the time of writing.\n  const isRefsTracker = (n: any): n is RefsTracker => n instanceof RefsTracker;\n  const isRefsNode = (n: any): n is RefsNode => !isRefsTracker(n);\n\n  for (const node of content) {\n    if (isRefsTracker(node)) {\n      refs = { ...refs, ...offsetRefs(node.refs, position) };\n    }\n    if (isRefsNode(node)) {\n      const thickness = node.isText ? 0 : 1;\n      refs = { ...refs, ...offsetRefs(node.refs, position + thickness) };\n      position += node.nodeSize;\n      nodes.push(node as RefsNode);\n    }\n  }\n  return { nodes, refs };\n}\n\n/**\n * Coerce builder content into ref nodes.\n */\nexport function coerce(content: BuilderContent[], schema: Schema) {\n  const refsContent = content.map(item =>\n    typeof item === 'string' ? text(item, schema) : item(schema),\n  ) as Array<RefsContentItem | RefsContentItem[]>;\n  return sequence(...flatten<RefsContentItem>(refsContent));\n}\n\n/**\n * Create a factory for nodes.\n */\nexport function nodeFactory(type: NodeType, attrs = {}, marks?: Mark[]) {\n  return (...content: BuilderContent[]): ((schema: Schema) => RefsNode) => {\n    return schema => {\n      const { nodes, refs } = coerce(content, schema);\n      const nodeBuilder = schema.nodes[type.name];\n      if (!nodeBuilder) {\n        throw new Error(\n          `Node: \"${\n            type.name\n          }\" doesn't exist in schema. It's usually caused by lacking of a plugin that contributes this node. Schema contains following nodes: ${Object.keys(\n            schema.nodes,\n          ).join(', ')}`,\n        );\n      }\n      const node = nodeBuilder.createChecked(attrs, nodes, marks) as RefsNode;\n      node.refs = refs;\n      return node;\n    };\n  };\n}\n\n/**\n * Create a factory for marks.\n */\nexport function markFactory(type: MarkType, attrs = {}, allowDupes = false) {\n  return (...content: BuilderContent[]): ((schema: Schema) => RefsNode[]) => {\n    return schema => {\n      const markBuilder = schema.marks[type.name];\n      if (!markBuilder) {\n        throw new Error(\n          `Mark: \"${\n            type.name\n          }\" doesn't exist in schema. It's usually caused by lacking of a plugin that contributes this mark. Schema contains following marks: ${Object.keys(\n            schema.marks,\n          ).join(', ')}`,\n        );\n      }\n      const mark = markBuilder.create(attrs);\n      const { nodes } = coerce(content, schema);\n      return nodes.map(node => {\n        if (!allowDupes && mark.type.isInSet(node.marks)) {\n          return node;\n        } else {\n          const refNode = node.mark(mark.addToSet(node.marks)) as RefsNode;\n          refNode.refs = node.refs;\n          return refNode;\n        }\n      });\n    };\n  };\n}\n\nexport const fragment = (...content: BuilderContent[]) => flatten<BuilderContent>(content);\nexport const slice = (...content: BuilderContent[]) =>\n  new Slice(Fragment.from(coerce(content, testSchema).nodes), 0, 0);\n\n/**\n * Builds a 'clean' version of the nodes, without Refs or RefTrackers\n */\nexport const clean = (content: BuilderContentFn) => (schema: Schema) => {\n  const node = content(schema);\n  if (Array.isArray(node)) {\n    return node.reduce(\n      (acc, next) => {\n        if (next instanceof Node) {\n          acc.push(Node.fromJSON(schema, next.toJSON()));\n        }\n        return acc;\n      },\n      [] as Node[],\n    );\n  }\n  return node instanceof Node ? Node.fromJSON(schema, node.toJSON()) : undefined;\n};\n"],"file":"builder.js"}