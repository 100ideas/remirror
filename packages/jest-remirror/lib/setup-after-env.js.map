{"version":3,"sources":["../src/setup-after-env.ts"],"names":["expect","extend","toEqualDocument","actual","expected","type","schema","PMNode","pass","name","message","equals","toJSON","utils","matcherHint","printExpected","printReceived","diffString","diff","expand","toMatchDocSnapshot","currentTestName","snapshotState","removeFirstWord","sentence","split","slice","join","newTestName","transformedDoc","oldCounters","_counters","Object","create","set","value","key","get","oldTestName","ret","toMatchSnapshot","call"],"mappings":";;AAAA;;AACA;;AAEAA,MAAM,CAACC,MAAP,CAAc;AACZC,EAAAA,eAAe,CAACC,MAAD,EAASC,QAAT,EAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,IAAAA,QAAQ,GACN,OAAOA,QAAP,KAAoB,UAApB,IAAkCD,MAAM,CAACE,IAAzC,IAAiDF,MAAM,CAACE,IAAP,CAAYC,MAA7D,GACIF,QAAQ,CAACD,MAAM,CAACE,IAAP,CAAYC,MAAb,CADZ,GAEIF,QAHN;;AAKA,QAAI,EAAEA,QAAQ,YAAYG,YAAtB,KAAiC,EAAEJ,MAAM,YAAYI,YAApB,CAArC,EAAkE;AAChE,aAAO;AACLC,QAAAA,IAAI,EAAE,KADD;AAELL,QAAAA,MAFK;AAGLC,QAAAA,QAHK;AAILK,QAAAA,IAAI,EAAE,iBAJD;AAKLC,QAAAA,OAAO,EAAE;AALJ,OAAP;AAOD;;AAED,QAAIN,QAAQ,CAACC,IAAT,CAAcC,MAAd,KAAyBH,MAAM,CAACE,IAAP,CAAYC,MAAzC,EAAiD;AAC/C,aAAO;AACLE,QAAAA,IAAI,EAAE,KADD;AAELL,QAAAA,MAFK;AAGLC,QAAAA,QAHK;AAILK,QAAAA,IAAI,EAAE,iBAJD;AAKLC,QAAAA,OAAO,EAAE;AALJ,OAAP;AAOD;;AAED,UAAMF,IAAI,GAAG,KAAKG,MAAL,CAAYR,MAAM,CAACS,MAAP,EAAZ,EAA6BR,QAAQ,CAACQ,MAAT,EAA7B,CAAb;AACA,UAAMF,OAAO,GAAGF,IAAI,GAChB,MACG,GAAE,KAAKK,KAAL,CAAWC,WAAX,CAAuB,sBAAvB,CAA+C,MAAlD,GACC,oDAAmD,KAAKD,KAAL,CAAWE,aAAX,CAAyBX,QAAzB,CAAmC,IADvF,GAEC,mBAAkB,KAAKS,KAAL,CAAWG,aAAX,CAAyBb,MAAzB,CAAiC,EAJtC,GAKhB,MAAM;AACJ,YAAMc,UAAU,GAAG,KAAKJ,KAAL,CAAWK,IAAX,CAAgBd,QAAhB,EAA0BD,MAA1B,EAAkC;AACnDgB,QAAAA,MAAM,EAAE,KAAKA;AADsC,OAAlC,CAAnB;AAGA,aACG,GAAE,KAAKN,KAAL,CAAWC,WAAX,CAAuB,kBAAvB,CAA2C,MAA9C,GACC,8CAA6C,KAAKD,KAAL,CAAWE,aAAX,CAAyBX,QAAzB,CAAmC,IADjF,GAEC,mBAAkB,KAAKS,KAAL,CAAWG,aAAX,CAAyBb,MAAzB,CAAiC,EAFpD,GAGC,GAAEc,UAAU,GAAI,sBAAqBA,UAAW,EAApC,GAAwC,EAAG,EAJ1D;AAMD,KAfL;AAiBA,WAAO;AACLT,MAAAA,IADK;AAELL,MAAAA,MAFK;AAGLC,MAAAA,QAHK;AAILM,MAAAA,OAJK;AAKLD,MAAAA,IAAI,EAAE;AALD,KAAP;AAOD,GA3DW;;AA6DZW,EAAAA,kBAAkB,CAACjB,MAAD,EAAS;AACzB,UAAM;AAAEkB,MAAAA,eAAF;AAAmBC,MAAAA;AAAnB,QAAqC,IAA3C;;AAEA,UAAMC,eAAe,GAAIC,QAAD,IACtBA,QAAQ,GACJA,QAAQ,CACLC,KADH,CACS,GADT,EAEGC,KAFH,CAES,CAFT,EAGGC,IAHH,CAGQ,GAHR,CADI,GAKJ,EANN,CAHyB,CAWzB;AACA;;;AACA,UAAMC,WAAW,GAAGL,eAAe,CAACF,eAAD,CAAnC,CAbyB,CAezB;;AACA,UAAMQ,cAAc,GAAG1B,MAAvB,CAhByB,CAkBzB;AACA;;AACA,UAAM2B,WAAW,GAAIR,aAAD,CAAuBS,SAA3C;AACCT,IAAAA,aAAD,CAAuBS,SAAvB,GAAmCC,MAAM,CAACC,MAAP,CAAcH,WAAd,EAA2B;AAC5DI,MAAAA,GAAG,EAAE;AACHC,QAAAA,KAAK,EAAGC,GAAD,IAAiBN,WAAW,CAACI,GAAZ,CAAgBE,GAAhB,EAAqB,CAArB;AADrB,OADuD;AAI5DC,MAAAA,GAAG,EAAE;AACHF,QAAAA,KAAK,EAAGC,GAAD,IAAiBN,WAAW,CAACO,GAAZ,CAAgBD,GAAhB;AADrB;AAJuD,KAA3B,CAAnC,CArByB,CA8BzB;AACA;;AACA,UAAME,WAAW,GAAG,KAAKjB,eAAzB;AACA,SAAKA,eAAL,GAAuBO,WAAvB;;AAEA,UAAMW,GAAG,GAAGC,8BAAgBC,IAAhB,CAAqB,IAArB,EAA2BZ,cAA3B,CAAZ;;AAEA,SAAKR,eAAL,GAAuBiB,WAAvB;AACA,WAAOC,GAAP;AACD;;AApGW,CAAd","sourcesContent":["import { PMNode } from '@remirror/core';\nimport { toMatchSnapshot } from 'jest-snapshot';\n\nexpect.extend({\n  toEqualDocument(actual, expected) {\n    // Because schema is created dynamically, expected value is a function (schema) => PMNode;\n    // That's why this magic is necessary. It simplifies writing assertions, so\n    // instead of expect(doc).toEqualDocument(doc(p())(schema)) we can just do:\n    // expect(doc).toEqualDocument(doc(p())).\n    //\n    // Also it fixes issues that happens sometimes when actual schema and expected schema\n    // are different objects, making this case impossible by always using actual schema to create expected node.\n    expected =\n      typeof expected === 'function' && actual.type && actual.type.schema\n        ? expected(actual.type.schema)\n        : expected;\n\n    if (!(expected instanceof PMNode) || !(actual instanceof PMNode)) {\n      return {\n        pass: false,\n        actual,\n        expected,\n        name: 'toEqualDocument',\n        message: 'Expected both values to be instance of prosemirror-model Node.',\n      };\n    }\n\n    if (expected.type.schema !== actual.type.schema) {\n      return {\n        pass: false,\n        actual,\n        expected,\n        name: 'toEqualDocument',\n        message: 'Expected both values to be using the same schema.',\n      };\n    }\n\n    const pass = this.equals(actual.toJSON(), expected.toJSON());\n    const message = pass\n      ? () =>\n          `${this.utils.matcherHint('.not.toEqualDocument')}\\n\\n` +\n          `Expected JSON value of document to not equal:\\n  ${this.utils.printExpected(expected)}\\n` +\n          `Actual JSON:\\n  ${this.utils.printReceived(actual)}`\n      : () => {\n          const diffString = this.utils.diff(expected, actual, {\n            expand: this.expand,\n          });\n          return (\n            `${this.utils.matcherHint('.toEqualDocument')}\\n\\n` +\n            `Expected JSON value of document to equal:\\n${this.utils.printExpected(expected)}\\n` +\n            `Actual JSON:\\n  ${this.utils.printReceived(actual)}` +\n            `${diffString ? `\\n\\nDifference:\\n\\n${diffString}` : ''}`\n          );\n        };\n\n    return {\n      pass,\n      actual,\n      expected,\n      message,\n      name: 'toEqualDocument',\n    };\n  },\n\n  toMatchDocSnapshot(actual) {\n    const { currentTestName, snapshotState } = this;\n\n    const removeFirstWord = (sentence?: string) =>\n      sentence\n        ? sentence\n            .split(' ')\n            .slice(1)\n            .join(' ')\n        : '';\n\n    // this change is to ensure we are mentioning test file name only once in snapshot file\n    // for integration tests only\n    const newTestName = removeFirstWord(currentTestName);\n\n    // remove ids that may change from the document so snapshots are repeatable\n    const transformedDoc = actual;\n\n    // since the test runner fires off multiple browsers for a single test, map each snapshot to the same one\n    // (otherwise we'll try to create as many snapshots as there are browsers)\n    const oldCounters = (snapshotState as any)._counters;\n    (snapshotState as any)._counters = Object.create(oldCounters, {\n      set: {\n        value: (key: string) => oldCounters.set(key, 1),\n      },\n      get: {\n        value: (key: string) => oldCounters.get(key),\n      },\n    });\n\n    // In `jest-snapshot@22`, passing the optional testName doesn't override test name anymore.\n    // Instead it appends the passed name with original name.\n    const oldTestName = this.currentTestName;\n    this.currentTestName = newTestName;\n\n    const ret = toMatchSnapshot.call(this, transformedDoc);\n\n    this.currentTestName = oldTestName;\n    return ret;\n  },\n});\n\ndeclare global {\n  namespace jest {\n    interface MatcherUtils {\n      currentTestName?: string;\n      snapshotState: any;\n    }\n  }\n}\n"],"file":"setup-after-env.js"}